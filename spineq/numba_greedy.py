import numpy as np
from typing import Union
from numba import jit


@jit(nopython=True)
def max_axis1(arr):
    # loop because numba doesn't support use of axis in np.max(..., axis=1)
    n = len(arr)
    maxes = np.zeros(n)
    for i in range(n):
        maxes[i] = np.max(arr[i, :])
    return maxes


@jit(nopython=True)
def add_sensor(sensors, coverage, weights):
    n_poi = len(sensors)
    new_coverages = np.zeros(n_poi)
    for site in range(n_poi):
        # try adding sensor at potential sensor site
        if sensors[site] == 1:
            # already have a sensor here, so skip to next
            continue

        new_sensors = sensors.copy()
        new_sensors[site] = 1
        # only keep coverages due to sites where a sensor is present
        mask_cov = coverage[:, new_sensors == 1]
        # coverage at each site = coverage due to nearest sensor
        max_mask_cov = max_axis1(mask_cov)
        # Avg coverage = weighted sum across all points of interest
        new_coverages[site] = (weights * max_mask_cov).sum() / weights.sum()

    best_idx = new_coverages.argmax()
    updated_sensors = sensors.copy()
    updated_sensors[best_idx] = 1
    return updated_sensors


@jit(nopython=True)
def greedy_opt(
    n_sensors: int,
    coverage: np.array,
    weights: Union[np.array, None] = None,
) -> np.array:
    """[summary]

     Parameters
     ----------
     n_sensors : int
         number of sensors to place
     coverage : np.Array
         coverage matrix as generated by spineq.utils.coverage_matrix. Should be of
         shape (n_sensor_sites, n_points_of_interest). Usually this is
         (n_output_areas, n_output_areas) as output area centroids are both our
         set of possible sensor sites and what we have data about people for.
     weights : Union[np.Arary, None], optional
         array of weights for each point of interest, should have same length as
         axis 1 of coverage. By default None which uses uniform weights.

     Returns
     -------
    dict
         Optimisation result
    """
    n_poi = coverage.shape[0]
    # binary array - 1 if sensor at this location, 0 if not
    sensors = np.zeros(n_poi)
    # set uniform weights if not given
    if weights is None:
        weights = np.ones(n_poi)

    for _ in range(n_sensors):
        sensors = add_sensor(sensors, coverage, weights)

    return sensors
