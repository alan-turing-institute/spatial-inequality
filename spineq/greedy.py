from typing import Union

import numpy as np


def greedy_opt(
    n_sensors: int,
    coverage: np.array,
    weights: Union[np.array, None] = None,
    verbose: bool = True,
    job=None,
    socketIO=None,
) -> dict:
    """[summary]

     Parameters
     ----------
     n_sensors : int
         number of sensors to place
     coverage : np.Array
         coverage matrix as generated by spineq.utils.coverage_matrix. Should be of
         shape (n_sensor_sites, n_points_of_interest). Usually this is
         (n_output_areas, n_output_areas) as output area centroids are both our
         set of possible sensor sites and what we have data about people for.
     weights : Union[np.Arary, None], optional
         array of weights for each point of interest, should have same length as
         axis 1 of coverage. By default None which uses uniform weights.
     verbose : bool, optional
         If True print progreses, by default True
     job : [type], optional
         RQ job running this optimisation call, by default None
     socketIO : [type], optional
         SocketIO client making this optimisation call, by default None

     Returns
     -------
    dict
         Optimisation result
    """
    n_poi = coverage.shape[0]
    # binary array - 1 if sensor at this location, 0 if not
    sensors = np.zeros(n_poi)
    # set uniform weights if not given
    if weights is None:
        weights = np.ones(n_poi)

    # coverage obtained with each number of sensors
    placement_history = []
    coverage_history = []

    for s in range(n_sensors):
        # greedily add sensors
        if verbose:
            print("Placing sensor", s + 1, "out of", n_sensors, "... ", end="")

        if job:
            job.meta["status"] = "Placing sensor {} out of {}".format(s + 1, n_sensors)
            progress = 100 * s / n_sensors
            job.meta["progress"] = progress
            job.save_meta()
            if socketIO is not None:
                socketIO.emit("jobProgress", {"job_id": job.id, "progress": progress})

        # initialise arrays to store best result so far
        best_total_coverage = 0
        best_sensors = sensors.copy()
        best_point_coverage = sensors.copy()

        for site in range(n_poi):
            # try adding sensor at potential sensor site
            if sensors[site] == 1:
                # already have a sensor here, so skip to next
                continue
            else:
                new_sensors = sensors.copy()
                new_sensors[site] = 1
                # only keep coverages due to sites where a sensor is present
                mask_cov = np.multiply(coverage, new_sensors[np.newaxis, :])
                # coverage at each site = coverage due to nearest sensor
                max_mask_cov = np.max(mask_cov, axis=1)
                # Avg coverage = weighted sum across all points of interest
                new_coverage = (weights * max_mask_cov).sum() / weights.sum()

                if new_coverage > best_total_coverage:
                    # this site is the best site for next sensor found so far
                    best_new_site = site
                    best_sensors = new_sensors.copy()
                    best_total_coverage = new_coverage
                    best_point_coverage = max_mask_cov

        sensors = best_sensors.copy()
        placement_history.append(best_new_site)
        coverage_history.append(best_total_coverage)
        point_coverage = best_point_coverage.copy()
        if verbose:
            print("coverage = {:.2f}".format(best_total_coverage))

    result = {
        "n_sensors": n_sensors,
        "sensors": sensors,
        "total_coverage": best_total_coverage,
        "point_coverage": point_coverage,
        "weights": weights,
        "placement_history": placement_history,
        "coverage_history": coverage_history,
    }
    return result
